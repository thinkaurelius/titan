package com.thinkaurelius.titan.diskstorage.util;

import com.codahale.metrics.Counter;
import com.codahale.metrics.Histogram;
import com.codahale.metrics.MetricRegistry;
import com.codahale.metrics.Timer;
import com.thinkaurelius.titan.diskstorage.StaticBuffer;
import com.thinkaurelius.titan.diskstorage.StorageException;
import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
import com.thinkaurelius.titan.util.stats.MetricManager;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.Callable;

/**
 * This class instruments an arbitrary KeyColumnValueStore backend with Metrics.
 * The cumulative runtime of, number of invocations of, and number of exceptions
 * thrown by each interface method are instrumented with Metrics (using Timer,
 * Counter, and Counter again, respectively). The Metric names are generated by
 * calling {@link MetricRegistry#name(backendClass, methodName, identifier)},
 * where methodName is the exact name of the method including capitalization,
 * and identifier is "time", "calls", or "exceptions".
 * <p/>
 * In addition to the three standard metrics, {@code getSlice} and
 * {@code getKeys} have some additional metrics related to their return values.
 * {@code getSlice} carries metrics with the identifiers "entries-returned" and
 * "entries-histogram". The first is a counter of total Entry objects returned.
 * The second is a histogram of the size of Entry lists returned.
 * {@code getKeys} returns a {@link RecordIterator} that manages metrics for its
 * methods.
 * <p/>
 * This implementation does not catch any exceptions. Exceptions emitted by the
 * backend store implementation are guaranteed to pass through this
 * implementation's methods.
 * <p/>
 * The implementation includes repeated {@code try...catch} boilerplate that
 * could be reduced by using reflection to determine the method name and by
 * delegating Metrics object handling to a common helper that takes a Callable
 * closure, but I'm not sure that the extra complexity and potential performance
 * hit is worth it.
 *
 * @author Dan LaRocque <dalaro@hopcount.org>
 */
public class MetricInstrumentedStore implements KeyColumnValueStore {

    private final KeyColumnValueStore backend;

    // containsKey
    private final Timer containsKeyTimer;
    private final Counter containsKeyInvocationCounter;
    private final Counter containsKeyFailureCounter;
    // getSlice
    private final Timer getSliceTimer;
    private final Counter getSliceColumnCounter;
    private final Histogram getSliceColumnHisto;
    private final Counter getSliceInvocationCounter;
    private final Counter getSliceFailureCounter;
    // mutate
    private final Timer mutateTimer;
    private final Counter mutateInvocationCounter;
    private final Counter mutateFailureCounter;
    // acquireLock
    private final Timer acquireLockTimer;
    private final Counter acquireLockInvocationCounter;
    private final Counter acquireLockFailureCounter;
    // getKeys
    private final Timer getKeysTimer;
    private final Counter getKeysInvocationCounter;
    private final Counter getKeysFailureCounter;
    private final String getKeysIteratorMetricPrefix;
    // getLocalKeyPartition
    private final Timer getLocalKeyPartitionTimer;
    private final Counter getLocalKeyPartitionInvocationCounter;
    private final Counter getLocalKeyPartitionFailureCounter;
    // getName
    private final Timer getNameTimer;
    private final Counter getNameInvocationCounter;
    private final Counter getNameFailureCounter;
    // close
    private final Timer closeTimer;
    private final Counter closeInvocationCounter;
    private final Counter closeFailureCounter;

    private static final Logger log =
            LoggerFactory.getLogger(MetricInstrumentedStore.class);

    public MetricInstrumentedStore(KeyColumnValueStore backend, String p) {
        this.backend = backend;

        MetricRegistry metrics = MetricManager.INSTANCE.getRegistry();

        containsKeyTimer =
                metrics.timer(MetricRegistry.name(p, "containsKey", "time"));
        containsKeyInvocationCounter =
                metrics.counter(MetricRegistry.name(p, "containsKey", "calls"));
        containsKeyFailureCounter =
                metrics.counter(MetricRegistry.name(p, "containsKey", "exceptions"));

        getSliceTimer =
                metrics.timer(MetricRegistry.name(p, "getSlice", "time"));
        getSliceInvocationCounter =
                metrics.counter(MetricRegistry.name(p, "getSlice", "calls"));
        getSliceFailureCounter =
                metrics.counter(MetricRegistry.name(p, "getSlice", "exceptions"));
        getSliceColumnCounter =
                metrics.counter(MetricRegistry.name(p, "getSlice", "entries-returned"));
        getSliceColumnHisto =
                metrics.histogram(MetricRegistry.name(p, "getSlice", "entries-histogram"));

        mutateTimer =
                metrics.timer(MetricRegistry.name(p, "mutate", "time"));
        mutateInvocationCounter =
                metrics.counter(MetricRegistry.name(p, "mutate", "calls"));
        mutateFailureCounter =
                metrics.counter(MetricRegistry.name(p, "mutate", "exceptions"));

        acquireLockTimer =
                metrics.timer(MetricRegistry.name(p, "acquireLock", "time"));
        acquireLockInvocationCounter =
                metrics.counter(MetricRegistry.name(p, "acquireLock", "calls"));
        acquireLockFailureCounter =
                metrics.counter(MetricRegistry.name(p, "acquireLock", "exceptions"));

        getKeysTimer =
                metrics.timer(MetricRegistry.name(p, "getKeys", "time"));
        getKeysInvocationCounter =
                metrics.counter(MetricRegistry.name(p, "getKeys", "calls"));
        getKeysFailureCounter =
                metrics.counter(MetricRegistry.name(p, "getKeys", "exceptions"));
        getKeysIteratorMetricPrefix = p + "." + "getKeys.iterator";

        getLocalKeyPartitionTimer =
                metrics.timer(MetricRegistry.name(p, "getLocalKeyPartition", "time"));
        getLocalKeyPartitionInvocationCounter =
                metrics.counter(MetricRegistry.name(p, "getLocalKeyPartition", "calls"));
        getLocalKeyPartitionFailureCounter =
                metrics.counter(MetricRegistry.name(p, "getLocalKeyPartition", "exceptions"));

        getNameTimer =
                metrics.timer(MetricRegistry.name(p, "getName", "time"));
        getNameInvocationCounter =
                metrics.counter(MetricRegistry.name(p, "getName", "calls"));
        getNameFailureCounter =
                metrics.counter(MetricRegistry.name(p, "getName", "exceptions"));

        closeTimer =
                metrics.timer(MetricRegistry.name(p, "close", "time"));
        closeInvocationCounter =
                metrics.counter(MetricRegistry.name(p, "close", "calls"));
        closeFailureCounter =
                metrics.counter(MetricRegistry.name(p, "close", "exceptions"));

        log.debug("Wrapped Metrics around store {} (metric prefix {})", backend, p);
    }

    @Override
    public boolean containsKey(StaticBuffer key, StoreTransaction txh) throws StorageException {
        containsKeyInvocationCounter.inc();
        Timer.Context tc = containsKeyTimer.time();

        try {
            return backend.containsKey(key, txh);
        } catch (StorageException e) {
            containsKeyFailureCounter.inc();
            throw e;
        } finally {
            tc.stop();
        }
    }

    @Override
    public List<Entry> getSlice(final KeySliceQuery query, final StoreTransaction txh) throws StorageException {
        return getSliceWithMetrics(new GetSliceCommand<List<Entry>>() {
            @Override
            public List<Entry> call() throws StorageException {
                List<Entry> result = backend.getSlice(query, txh);
                recordSliceMetrics(result);
                return result;
            }
        });
    }

    @Override
    public List<List<Entry>> getSlice(final List<StaticBuffer> keys,
                                      final SliceQuery query,
                                      final StoreTransaction txh) throws StorageException {
        return getSliceWithMetrics(new GetSliceCommand<List<List<Entry>>>() {
            @Override
            public List<List<Entry>> call() throws StorageException {
                List<List<Entry>> results = backend.getSlice(keys, query, txh);

                for (List<Entry> result : results) {
                    recordSliceMetrics(result);
                }

                return results;
            }
        });
    }

    private <V> V getSliceWithMetrics(GetSliceCommand<V> getSliceCommand) throws StorageException {
        getSliceInvocationCounter.inc();
        Timer.Context tc = getSliceTimer.time();

        try {
            return getSliceCommand.call();
        } catch (StorageException e) {
            getSliceFailureCounter.inc();
            throw e;
        } finally {
            tc.stop();
        }
    }

    private void recordSliceMetrics(List<Entry> row) {
        getSliceColumnCounter.inc(row.size());
        getSliceColumnHisto.update(row.size());
    }

    @Override
    public void mutate(StaticBuffer key,
                       List<Entry> additions,
                       List<StaticBuffer> deletions,
                       StoreTransaction txh) throws StorageException {
        mutateInvocationCounter.inc();
        Timer.Context tc = mutateTimer.time();

        try {
            backend.mutate(key, additions, deletions, txh);
        } catch (StorageException e) {
            mutateFailureCounter.inc();
            throw e;
        } finally {
            tc.stop();
        }
    }

    @Override
    public void acquireLock(StaticBuffer key,
                            StaticBuffer column,
                            StaticBuffer expectedValue,
                            StoreTransaction txh) throws StorageException {
        acquireLockInvocationCounter.inc();
        Timer.Context tc = acquireLockTimer.time();

        try {
            backend.acquireLock(key, column, expectedValue, txh);
        } catch (StorageException e) {
            acquireLockFailureCounter.inc();
            throw e;
        } finally {
            tc.stop();
        }
    }

    @Override
    public KeyIterator getKeys(final KeyRangeQuery query, final StoreTransaction txh) throws StorageException {
        return getKeysWithMetrics(new KeyIteratorCommand() {
            @Override
            public KeyIterator call() throws StorageException {
                return backend.getKeys(query, txh);
            }
        });
    }

    @Override
    public KeyIterator getKeys(final SliceQuery query, final StoreTransaction txh) throws StorageException {
        return getKeysWithMetrics(new KeyIteratorCommand() {
            @Override
            public KeyIterator call() throws StorageException {
                return backend.getKeys(query, txh);
            }
        });
    }

    private KeyIterator getKeysWithMetrics(KeyIteratorCommand command) throws StorageException {
        getKeysInvocationCounter.inc();
        final Timer.Context tc = getKeysTimer.time();

        try {
            return MetricInstrumentedIterator.of(command.call(), getKeysIteratorMetricPrefix);
        } catch (StorageException e) {
            getKeysFailureCounter.inc();
            throw e;
        } finally {
            tc.stop();
        }
    }

    @Override
    public StaticBuffer[] getLocalKeyPartition() throws StorageException {
        getLocalKeyPartitionInvocationCounter.inc();
        Timer.Context tc = getLocalKeyPartitionTimer.time();

        try {
            return backend.getLocalKeyPartition();
        } catch (StorageException e) {
            getLocalKeyPartitionFailureCounter.inc();
            throw e;
        } finally {
            tc.stop();
        }
    }

    @Override
    public String getName() {
        getNameInvocationCounter.inc();
        Timer.Context tc = getNameTimer.time();

        try {
            return backend.getName();
        } catch (RuntimeException e) {
            getNameFailureCounter.inc();
            throw e;
        } finally {
            tc.stop();
        }
    }

    @Override
    public void close() throws StorageException {
        closeInvocationCounter.inc();
        Timer.Context tc = closeTimer.time();

        try {
            backend.close();
        } catch (StorageException e) {
            closeFailureCounter.inc();
            throw e;
        } finally {
            tc.stop();
        }
    }

    private static interface KeyIteratorCommand extends Callable<KeyIterator> {
        @Override
        public KeyIterator call() throws StorageException;
    }

    private static interface GetSliceCommand<V> extends Callable<V> {
        @Override
        public V call() throws StorageException;
    }
}
